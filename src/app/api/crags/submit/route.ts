import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { getSupabaseClient, isSupabaseConfigured } from "@/integrations/supabase/client";

// Validation schema for crag submission
const CragSubmissionSchema = z.object({
  name: z.string().min(1, "Name is required").max(255),
  lat: z.number().min(-90).max(90),
  lon: z.number().min(-180).max(180),
  country: z.string().min(2).max(2), // ISO 3166-1 alpha-2 code
  state: z.string().optional(),
  municipality: z.string().optional(),
  village: z.string().optional(),
  rockType: z.string().optional(),
  aspects: z.array(z.number().min(0).max(360)).optional(),
  climbingTypes: z.array(z.string()).optional(),
  description: z.string().max(5000).optional(),
  osmId: z.string().optional(),
  osmType: z.enum(["node", "way", "relation"]).optional(),
  parentCragId: z.string().uuid().optional(), // For creating sectors under a parent crag
});

type CragSubmission = z.infer<typeof CragSubmissionSchema>;

/**
 * POST /api/crags/submit
 * Submit a new crag to the database
 *
 * Body: CragSubmission object
 */
export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured) {
      console.error("Supabase environment variables are not configured.");
      return NextResponse.json({ error: "Supabase client is not configured" }, { status: 500 });
    }

    const body = await request.json();

    // Validate input
    const validationResult = CragSubmissionSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        {
          error: "Validation failed",
          details: validationResult.error.issues,
        },
        { status: 400 }
      );
    }

    const data: CragSubmission = validationResult.data;
    const supabase = getSupabaseClient();

    // Note: We no longer block submission based on nearby crags here.
    // The check is done proactively when the user sets the position,
    // and they see a warning. They can choose to proceed anyway.
    // This allows adding parent crags when only sectors exist, etc.

    // Insert new crag/sector - slug will be auto-generated by database trigger
    const { data: newCrag, error: insertError } = await supabase
      .from("crags")
      .insert({
        name: data.name,
        lat: data.lat,
        lon: data.lon,
        country: data.country,
        state: data.state || null,
        municipality: data.municipality || null,
        village: data.village || null,
        rock_type: data.rockType || null,
        aspects: data.aspects || null,
        climbing_types: data.climbingTypes || null,
        description: data.description || null,
        osm_id: data.osmId || null,
        osm_type: data.osmType || null,
        parent_crag_id: data.parentCragId || null, // Set for sectors, null for top-level crags
        source: "user_submitted",
        slug: "", // Empty string will be replaced by database trigger with unique slug
      })
      .select("id")
      .single();

    if (insertError) {
      console.error("Error inserting crag:", insertError);
      return NextResponse.json(
        { error: "Failed to create crag. Please try again." },
        { status: 500 }
      );
    }

    // Fetch the crag again to get the generated slug
    // The AFTER INSERT trigger runs asynchronously, so we need a second query
    const { data: cragWithSlug, error: fetchError } = await supabase
      .from("crags")
      .select("id, name, slug, slug_id, lat, lon")
      .eq("id", newCrag.id)
      .single();

    if (fetchError || !cragWithSlug) {
      console.error("Error fetching crag with slug:", fetchError);
      // Return partial data if slug fetch fails
      return NextResponse.json(
        {
          success: true,
          message: "Crag added successfully",
          crag: { ...newCrag, slug: "", slug_id: 0, lat: data.lat, lon: data.lon },
        },
        { status: 201 }
      );
    }

    return NextResponse.json(
      {
        success: true,
        message: "Crag added successfully",
        crag: cragWithSlug,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Crag submission error:", error);
    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : "An unexpected error occurred",
      },
      { status: 500 }
    );
  }
}
